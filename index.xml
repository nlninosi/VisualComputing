<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Presentación</title><link>https://nlninosi.github.io/showcase/</link><description>Recent content in Introduction on Presentación</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://nlninosi.github.io/showcase/index.xml" rel="self" type="application/rss+xml"/><item><title>Creating a New Theme</title><link>https://nlninosi.github.io/showcase/posts/creating-a-new-theme/</link><pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate><guid>https://nlninosi.github.io/showcase/posts/creating-a-new-theme/</guid><description>Introduction # This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description></item><item><title>Migrate to Hugo from Jekyll</title><link>https://nlninosi.github.io/showcase/posts/migrate-from-jekyll/</link><pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate><guid>https://nlninosi.github.io/showcase/posts/migrate-from-jekyll/</guid><description>Move static content to static # Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like
▾ &amp;lt;root&amp;gt;/ ▾ images/ logo.png should become
▾ &amp;lt;root&amp;gt;/ ▾ static/ ▾ images/ logo.png Additionally, you&amp;rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.</description></item><item><title>(Hu)go Template Primer</title><link>https://nlninosi.github.io/showcase/posts/goisforlovers/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>https://nlninosi.github.io/showcase/posts/goisforlovers/</guid><description>Hugo uses the excellent Go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in Go templates.
This document is a brief primer on using Go templates.</description></item><item><title>Getting Started with Hugo</title><link>https://nlninosi.github.io/showcase/posts/hugoisforlovers/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>https://nlninosi.github.io/showcase/posts/hugoisforlovers/</guid><description>Step 1. Install Hugo # Go to Hugo releases and download the appropriate version for your OS and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at Install Hugo
Step 2. Build the Docs # Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:</description></item><item><title/><link>https://nlninosi.github.io/showcase/docs/shortcodes/3D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nlninosi.github.io/showcase/docs/shortcodes/3D/</guid><description>Juegos pirotecnicos # Expand ↕ const fireworks = []; let gravity; let sel; let particles = []; let slider; let checkbox; let mode = &amp;#39;Explotions&amp;#39;; function setup() { createCanvas(600,600, WEBGL) angleMode(DEGREES) gravity = createVector(0, 0.2, 0); sel = createSelect(); sel.position(10, 10); sel.option(&amp;#39;Explotions&amp;#39;); sel.option(&amp;#39;Click&amp;#39;); sel.option(&amp;#39;Fireworks&amp;#39;); sel.changed(mySelectEvent); slider = createSlider(1, 255, 100); slider.position(10, 30); slider.style(&amp;#39;width&amp;#39;, &amp;#39;100px&amp;#39;); checkbox = createCheckbox(&amp;#39;Iluminacion&amp;#39;, true); } function mySelectEvent() { mode = sel.value(); } function draw() { background(240,100,10) if (checkbox.</description></item><item><title/><link>https://nlninosi.github.io/showcase/docs/shortcodes/Flower3d/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nlninosi.github.io/showcase/docs/shortcodes/Flower3d/</guid><description>Flower # Para este ejercicio es necesario usar las coordenadas polares en el plano cartesiano como se ve en la siguiente imagen:
Imagen base Coordenadas polares a coordenadas cartesianas # Como estamos pasando de coordenadas polares a coordenadas cartesianas, sucede algo curioso, el phi que esta dentro del seno si esta valor es un numero par el numero de petalos de la flor sera la mitad de dicho numero, pero si el numero es impar el numero de petalos sera el mismo numero.</description></item><item><title/><link>https://nlninosi.github.io/showcase/docs/shortcodes/Histogram/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nlninosi.github.io/showcase/docs/shortcodes/Histogram/</guid><description>Histograma # Un histograma de imagen es un tipo de histograma que actúa como una representación gráfica de la distribución tonal en una imagen digital. Representa el número de píxeles de cada valor tonal. Al observar el histograma de una imagen concreta, el espectador podrá juzgar toda la distribución tonal de un vistazo.
Nuestra implementacion del histograma se hizo de la manera siguiente:
Expand ↕ var stateR; var stateG; var stateB; var red_arr = new Array(256); var green_arr = new Array(256); var blue_arr = new Array(256); var showFilter = false; const filter = [ [-2, -1, 0], [-1, 1, 1], [0, 1, 2], ]; const filter2 = [ [-1, 0, 1], [-1, 0, 1], [-1, 0, 1], ]; var colors = new Array(3); var leftM = 30; var upM = 15; function preload() { img = loadImage(&amp;#34;/showcase/assets/1.</description></item><item><title/><link>https://nlninosi.github.io/showcase/docs/shortcodes/illusions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nlninosi.github.io/showcase/docs/shortcodes/illusions/</guid><description>Illusions # Definición del problema # Estudiar, poner en práctica y discutir las posibles aplicaciones de algunos fenómenos visuales e ilusiones ópticas conocidos.
Sustento teórico # Una ilusión óptica es cualquier ilusión del sentido de la visión que nos lleva a percibir la realidad de varias formas. Puede ser de carácter fisiológico, asociada a los efectos de una estimulación anómala o excesiva en los ojos o el cerebro o de carácter cognitivo, en las que interviene nuestro conocimiento del mundo.</description></item><item><title/><link>https://nlninosi.github.io/showcase/docs/shortcodes/Masking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nlninosi.github.io/showcase/docs/shortcodes/Masking/</guid><description>Masking # Definición del problema # Sustento teórico # Que es el Masking? # Uno de los procedimientos experimentales más destacados para manipular la conciencia es el enmascaramiento visual, en el que se disminuye la visibilidad de un estímulo objetivo presentándolo en estrecha proximidad espacial y temporal con una denominada &amp;ldquo;máscara&amp;rdquo;. Por ejemplo, si se presenta una imagen objetivo solamente durante períodos breves, normalmente se puede percibir sin esfuerzo. Sin embargo, si la imagen objetivo breve es seguida inmediatamente por una segunda imagen consistente en una disposición de líneas y patrones aleatorios, su visibilidad se reduce considerablemente.</description></item><item><title/><link>https://nlninosi.github.io/showcase/docs/shortcodes/Shaders/coloring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nlninosi.github.io/showcase/docs/shortcodes/Shaders/coloring/</guid><description>Coloring # Blending # Color blending is a way to mix two colors together to produce to third color. These colors are called source and destination and they are in form [R,G,B,A] where R, G, B, A ∈ [0&amp;hellip;1]. Usually we use blending to represent semi transparent objects like glass. However we can also create interesting effects by changing some parameters in the blend function.
Alpha
So far we know that the color value is a vector space element that consists of R, G and B channels and sometimes has also an alpha channel.</description></item><item><title/><link>https://nlninosi.github.io/showcase/docs/shortcodes/Shaders/Image-Processing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nlninosi.github.io/showcase/docs/shortcodes/Shaders/Image-Processing/</guid><description>Que es el Masking? # Uno de los procedimientos experimentales más destacados para manipular la conciencia es el enmascaramiento visual, en el que se disminuye la visibilidad de un estímulo objetivo presentándolo en estrecha proximidad espacial y temporal con una denominada &amp;ldquo;máscara&amp;rdquo;. Por ejemplo, si se presenta una imagen objetivo solamente durante períodos breves, normalmente se puede percibir sin esfuerzo. Sin embargo, si la imagen objetivo breve es seguida inmediatamente por una segunda imagen consistente en una disposición de líneas y patrones aleatorios, su visibilidad se reduce considerablemente.</description></item><item><title/><link>https://nlninosi.github.io/showcase/docs/shortcodes/Shaders/procedural_texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nlninosi.github.io/showcase/docs/shortcodes/Shaders/procedural_texturing/</guid><description>Procedural Texturing # El objetivo de la texturización procesal es generar una textura mediante un algoritmo de tal manera que el resultado se pueda asignar a una forma como textura. La textura de procedimiento requiere el uso de un objeto de búfer de cuadro que en p5.js se implementa como un objeto p5.Graphics.
Offset patterns: # Un ejemplo de un patron compensado (offset patterns) es un muro de ladrillos, donde por cada fila alterna tenemos un ladrillo desplazado en el eje x.</description></item><item><title/><link>https://nlninosi.github.io/showcase/docs/shortcodes/Shaders/SpatialCoherence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nlninosi.github.io/showcase/docs/shortcodes/Shaders/SpatialCoherence/</guid><description> Spatial Coherence # Nuestra implementacion del pixelador usa coherencia espacial para submuestrear una imagen y de esta manera convertirlo es un texel. Nuestra implementacion tambien permite cambiar las dimensiones de los pixeles, el primer slider altera el ancho de los pixeles, mientras que el segundo el alto. Ademas de incluir nuestro propio dataset de imagenes.
// Conclusiones y trabajo a futuro #</description></item><item><title/><link>https://nlninosi.github.io/showcase/docs/shortcodes/Shaders/Texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nlninosi.github.io/showcase/docs/shortcodes/Shaders/Texturing/</guid><description>Texturing # Texturing es la manera de cómo se sitúa una textura (Una imagen) sobre un objeto al momento de proyectarse sobre un objeto. De este modo, un objeto obtiene una textura superficial similar a la de una superficie bidimensional. Es el equivalente digital de empapelar, pintar o cubrir cualquier superficie y por lo general es aplicada a objetos 3D.
Uv space # Los shaders que vamos a utilizar un el mapeado UV, donde se asigna una coordenada para cada vértice del objeto que más adelante se va a texturizar.</description></item></channel></rss>